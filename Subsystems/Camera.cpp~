// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Camera.h"
#include "../Robotmap.h"
#include "Vision/RGBImage.h"
#include "Vision/BinaryImage.h"
#include <time.h>
#include "../Robot.h"
#include <iostream>
#include <fstream>
#include <math.h>
#define AREA_MINIMUM 500
#define min(a,b) ((a)<(b)) ? (a):(b)
#define max(a,b) ((a)>(b)) ? (a):(b)
//Score limits used for target identification
#define RECTANGULARITY_LIMIT 60
#define ASPECT_RATIO_LIMIT 55
#define X_EDGE_LIMIT 40
#define Y_EDGE_LIMIT 60
extern "C" unsigned long niTimestamp32();
int TARGETING(int arg);
double scoreRectangularity(ParticleAnalysisReport *report);
double scoreAspectRatio(BinaryImage *image, ParticleAnalysisReport *report, bool outer);
bool scoreCheck(Camera::Scores &scores, bool outer);
bool scoreCompare(Camera::Scores *score1, Camera::Scores *score2);
Camera::Camera() :	Subsystem("Camera"),
					m_camera(AxisCamera::GetInstance("10.19.82.11")),
					image(IMAQ_IMAGE_HSL),
					m_targeting("targeting",(FUNCPTR)TARGETING, 110, 256000),
					m_prevCapture(false),
					m_scores(0)
{
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
	printf("Camera Started");
}
    
void Camera::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
	m_targeting.Start((UINT32)this);
		
	std::cout<< "camera constructor"<<std::endl;
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void Camera::TargetingTask()
{
	std::cout<< "Camera task"<<std::endl;
	
	ParticleFilterCriteria2 criteria[] = {
			{IMAQ_MT_AREA, AREA_MINIMUM, 65535, false, false}
							};
	
	bool tg_found;
	float targetxtemp = -99;
	float targetytemp = -99;
	targetx = 0;
	targety = 0;
	
	while(true)
	{
		if (m_camera.IsFreshImage())
		{
			int ts = niTimestamp32()/33000;
			
			m_camera.GetImage(&image);
			
			//BinaryImage *thresholdImage = image.ThresholdHSI(80, 120, 30, 255, 0, 255);	// get just the green target pixels
			BinaryImage *thresholdImage = image.ThresholdHSI(80, 125, 80, 255, 70, 255);
			BinaryImage *convexHullImage = thresholdImage->ConvexHull(false);
			BinaryImage *filteredImage = convexHullImage->ParticleFilter(criteria, 1);	//Remove small particles
			  // fill in partial and full rectangles
			
			
			
			vector<ParticleAnalysisReport> *reports = filteredImage->GetOrderedParticleAnalysisReports();  //get a particle analysis report for each particle
			delete [] m_scores;
			m_scores = new Scores[reports->size()];
			tg_found = false;
			
			Scores *bestScore = 0;
			ParticleAnalysisReport *bestreport = 0;
			
			for (unsigned i = 0; i < reports->size(); i++)
			{
				ParticleAnalysisReport *report = &(reports->at(i));
				tg_found = true;
				m_scores[i].rectangularity = scoreRectangularity(report);
				m_scores[i].aspectRatioOuter = scoreAspectRatio(filteredImage, report, true);
				m_scores[i].aspectRatioInner = scoreAspectRatio(filteredImage, report, false);
				m_scores[i].xCtr = report->center_mass_x_normalized;
				m_scores[i].yCtr = report->center_mass_y_normalized;				
				
				SmartDashboard::PutNumber("Outer Aspect Ratio", m_scores[i].aspectRatioOuter);
				SmartDashboard::PutNumber("Inner Aspect Ratio", m_scores[i].aspectRatioInner);
				SmartDashboard::PutNumber("Rectangularity", m_scores[i].rectangularity);
				
				if(true || scoreCheck(m_scores[i], true))
				{
					if(scoreCompare(&m_scores[i], bestScore))
					{
						bestScore = &m_scores[i];
						bestreport = report;
						targetxtemp = report->center_mass_x_normalized;
						targetytemp = report->center_mass_y_normalized;
						
					}
				}
			}
			
			if(Robot::oi->getxBox()->GetRawButton(3))
			{
				if(!m_prevCapture)
				{
					std::cout<< "BUTTON PRESSED"<<std::endl;
					
					m_prevCapture = true;
				
					char filename[32];
					sprintf(filename,"/camera_%d.jpeg",ts/1000);
					image.Write(filename);
					
					sprintf(filename,"/threshold_%d.bmp",ts/1000);
					thresholdImage->Write(filename);
					
					sprintf(filename,"/convexHull_%d.bmp",ts/1000);
					convexHullImage->Write(filename);
					
					sprintf(filename,"/filtered_%d.bmp",ts/1000);
					filteredImage->Write(filename);
					
					std::cout<< "Camera image taken"<<std::endl;
					
					if(bestreport != 0)
					{
					
						sprintf(filename,"/Score_%d.txt",ts/1000);
						std::ofstream scorefile(filename);
						
						scorefile<<"Center X"<<bestreport->center_mass_x_normalized<<std::endl;
						scorefile<<"Center Y"<<bestreport->center_mass_y_normalized<<std::endl;
						scorefile<<"Height"<<bestreport->boundingRect.height<<std::endl;
						scorefile<<"Width"<<bestreport->boundingRect.width<<std::endl;					
						scorefile<<"ParticleArea"<<bestreport->particleArea<<std::endl;
					}
				}
			}
			else
				m_prevCapture = false;
			
			SmartDashboard::PutNumber("Reports", reports->size());
					
			if (targetytemp != -99.0f)
			{
				targety = 0.8*targety + 0.2* targetytemp; 
			}
			if (targetxtemp != - 99.0f)
			{
				targetx = 0.8*targetx + 0.2* targetxtemp;
			}
			
			SmartDashboard::PutNumber("Target Y Temperarily",targetytemp);
			SmartDashboard::PutNumber("Target X Temperarily",targetxtemp);
			SmartDashboard::PutNumber("Target X", targetx);
			SmartDashboard::PutNumber("Target Y", targety);
			
			
			delete thresholdImage;
			delete convexHullImage;
			delete filteredImage;
			
		}
		else
		{
			Wait(0.005);
		}
	}
}
float Camera::GetTargetx()
{
	return targetx;
}
float Camera::GetTargety()
{
	return targety;
}
int TARGETING(int arg)
{
	Camera* obj = (Camera*)arg;
	obj->TargetingTask();
	return 0;
}
/**
 * Computes a score (0-100) estimating how rectangular the particle is by comparing the area of the particle
 * to the area of the bounding box surrounding it. A perfect rectangle would cover the entire bounding box.
 * 
 * @param report The Particle Analysis Report for the particle to score
 * @return The rectangularity score (0-100)
 */
double scoreRectangularity(ParticleAnalysisReport *report)
{
	if(report->boundingRect.width*report->boundingRect.height !=0){
		return 100*report->particleArea/(report->boundingRect.width*report->boundingRect.height);
	} else {
		return 0;
	}	
}
/**
 * Computes a score (0-100) comparing the aspect ratio to the ideal aspect ratio for the target. This method uses
 * the equivalent rectangle sides to determine aspect ratio as it performs better as the target gets skewed by moving
 * to the left or right. The equivalent rectangle is the rectangle with sides x and y where particle area= x*y
 * and particle perimeter= 2x+2y
 * 
 * @param image The image containing the particle to score, needed to perform additional measurements
 * @param report The Particle Analysis Report for the particle, used for the width, height, and particle number
 * @param outer	Indicates whether the particle aspect ratio should be compared to the ratio for the inner target or the outer
 * @return The aspect ratio score (0-100)
 */
double scoreAspectRatio(BinaryImage *image, ParticleAnalysisReport *report, bool outer)
{
	double rectLong, rectShort, idealAspectRatio, aspectRatio;
	idealAspectRatio = outer ? (62/29) : (62/20);	//Dimensions of goal opening + 4 inches on all 4 sides for reflective tape
	
	imaqMeasureParticle(image->GetImaqImage(), report->particleIndex, 0, IMAQ_MT_EQUIVALENT_RECT_LONG_SIDE, &rectLong);
	imaqMeasureParticle(image->GetImaqImage(), report->particleIndex, 0, IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE, &rectShort);
	
	//Divide width by height to measure aspect ratio
	if(report->boundingRect.width > report->boundingRect.height){
		//particle is wider than it is tall, divide long by short
		aspectRatio = 100*(1-fabs((1-((rectLong/rectShort)/idealAspectRatio))));
	} else {
		//particle is taller than it is wide, divide short by long
		aspectRatio = 100*(1-fabs((1-((rectShort/rectLong)/idealAspectRatio))));
	}
	return (max(0, min(aspectRatio, 100)));		//force to be in range 0-100
}
/**
 * Compares scores to defined limits and returns true if the particle appears to be a target
 * 
 * @param scores The structure containing the scores to compare
 * @param outer True if the particle should be treated as an outer target, false to treat it as a center target
 * 
 * @return True if the particle meets all limits, false otherwise
 */
bool scoreCheck(Camera::Scores &scores, bool outer){
	bool isTarget = true;
	isTarget &= scores.rectangularity > RECTANGULARITY_LIMIT;
	if(outer){
		isTarget &= scores.aspectRatioOuter > ASPECT_RATIO_LIMIT;
	} else {
		isTarget &= scores.aspectRatioInner > ASPECT_RATIO_LIMIT;
	}
	isTarget &= scores.xEdge > X_EDGE_LIMIT;
	isTarget &= scores.yEdge > Y_EDGE_LIMIT;
	return isTarget;
}
#define SCORE1 true
#define SCORE2 false
bool scoreCompare(Camera::Scores *score1, Camera::Scores *score2){
	if(score2 == 0)
		return SCORE1;
	
	if(score2->rectangularity > 70 && score1->rectangularity >70)
	{
		if(fabs(score1->xCtr) > fabs(score2->xCtr))
			return SCORE2;
		else
			return SCORE1;
	}
	else
	{
		if(score2->aspectRatioOuter > 71 && score2->aspectRatioOuter < 88)
			return SCORE2;
		else
			return SCORE1;
	}
}
